{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ksux","text":"<p>Easy and fast customization of kubernetes templates.</p>"},{"location":"#why","title":"Why?","text":"<p>Patching kubernetes manifests does not have to be tedious. <code>kustomize</code> and <code>helm</code> make this unnecessarily difficult, although they are great at what they were meant to do.</p> <p><code>ksux</code> aims to fill a hole where a small project requires patching existing manifests. Let's say that you have the following file structure:</p> <pre><code>|- base\n|  |- deployment.yaml\n|  |- service.yaml\n|  |- configmap.yaml\n|- dev\n|- staging\n|- prod\n</code></pre> <p>where your <code>base</code> folder contains kubernetes manifest templates, and the <code>dev</code>, <code>staging</code> and <code>prod</code> folders should contain patched templates from the base dir. How to do it?</p> <p>We propose a simple solution. Just create a new directory <code>patches</code> (or whatever name you like) and create (a) patch file(s).</p> <pre><code>|- base\n|  |- deployment.yaml\n|  |- service.yaml\n|  |- configmap.yaml\n|- dev\n|- staging\n|- prod\n|- patches\n|- |- deployment_patch.yaml\n</code></pre> <p>The content of the patch file should be composed of a list of patches (not necessary if the file will contain only one patch) where each patch must adhere to following structure:</p> <pre><code>name: &lt;patch_description&gt;\ntarget:\n  apiVersion: &lt;apiVersion of targeted resource&gt;\n  kind: &lt;Deployment type of targeted resource&gt;\n  name: &lt;name of targeted resource&gt;\nops:\n  - name: &lt;operation description&gt;\n    path: &lt;path to the part of the manifest to be patched&gt;\n    value: &lt;value which should be replaced or added&gt;\n    action: &lt;add|replace|remove&gt;\n</code></pre> <p>e.g. say you wish to change the image for a deployment called web to <code>nginx:1.23</code>:</p> <p>Tip</p> <p>Pay close attention to the <code>path</code> attribute of the first operation. We need to target a container from a list of containers. In <code>kustomize</code> you can do this only by specifying index of an element in a list which is baaaad (<code>/spec/template/spec/containers/0/image</code> for obvious reasons). We allow you to target a resource in a list by its name, which is more robust towards item order changes in a list.</p> <pre><code>name: deployment_patches\ntarget:\n  apiVersion: apps/v1\n  kind: Deployment\n  name: web\nops:\n- name: replace_image\n  path: /spec/template/spec/containers/nginx/image\n  value: nginx:1.23\n  action: replace\n</code></pre> <p>then just call following command to generate patched manifest to <code>dev</code> folder:</p> <pre><code>ksux -b base/ -p patches/ -o dev/\n</code></pre> <p>Info</p> <p>By default, ksux will output files in <code>json</code> format. <code>yaml</code> is supported as well, just add the <code>-e yaml</code> flag to the <code>ksux</code> command. However, we recommend using templates in json format. <code>YAML</code> is great for readability, but error-prone. We tried to make sure that the yaml stays as intact as possible, however <code>json</code> should be the safe choice.</p>"},{"location":"arguments/","title":"Arguments","text":"<p>You can see all options by running:</p> <pre><code>ksux --help\n</code></pre>"},{"location":"arguments/#-b-base_dir","title":"<code>-b</code> / <code>--base_dir</code>","text":"<p>Directory with all your base manifests which are to be patched. Only manifests with <code>.yaml</code>, <code>.yml</code> or <code>.json</code> extension will be considered</p>"},{"location":"arguments/#-p-patches_dir","title":"<code>-p</code> / <code>--patches_dir</code>","text":"<p>Patches which will be applied to your base manifests. Only patches with <code>.yaml</code>, <code>.yml</code> or <code>.json</code> extension will be considered</p>"},{"location":"arguments/#-o-output_dir","title":"<code>-o</code> / <code>--output_dir</code>","text":"<p>Path to a directory where the results should be saved. The directory will be created if it does not exist</p>"},{"location":"arguments/#-e-output_extension","title":"<code>-e</code> / <code>--output_extension</code>","text":"<p>Extension of patched manifests. Default is <code>json</code>. Other allowed options are <code>yaml</code> and <code>yml</code>. <code>JSON</code> format is recommended, as it is more robust than <code>yaml</code></p>"},{"location":"arguments/#-patched_only","title":"<code>--patched_only</code>","text":"<p>Save only patched manifest. By default, all manifests in the <code>base</code> directory whether patched or not will be saved to the <code>output</code> directory</p>"},{"location":"arguments/#-x-exclude","title":"<code>-x</code> / <code>--exclude</code>","text":"<p>Exclude one or more resources. The format for excluding a resource must be: <code>{apiVersion}_{kind}_{name}</code>. E.g. if you want to exclude service with name <code>my-svc</code>:</p> <pre><code>ksux -b /path/to/base -p /path/to/patches -o /patch/to/output -x v1_Service_my-svc\n</code></pre>"},{"location":"arguments/#-dry-run","title":"<code>--dry-run</code>","text":"<p>print patched manifests to stdout. For readability, it is recommended to supply the <code>-e yaml</code> flag, otherwise the output will be in json format </p>"},{"location":"arguments/#-q-quiet","title":"<code>-q</code> / <code>--quiet</code>","text":"<p>set logging level to <code>ERROR</code></p>"},{"location":"arguments/#-version","title":"<code>--version</code>","text":"<p>Print package version</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#pypi","title":"Pypi","text":"<p><code>ksux</code> is a python package. All you need to do is run:</p> <pre><code>pip install ksux\n</code></pre> <p>Note</p> <p>It is recommended to use a virtual environment. Do not install the package to your base environment. You can easily set up a virtual environment with one of following commands (or any other of your favorite implementations):  <pre><code># activate with \"source ksux/bin/activate\" \npython -m venv ksux\nvirtualenv ksux\n\n# activate with \"conda activate ksux\"\nconda create -n ksux ksux\n</code></pre></p>"},{"location":"installation/#docker","title":"Docker","text":"<p>There is also a docker image which is great for use in CI. However, you can use it as a command line tool as well. The only difference from running <code>ksux</code> directly, is the necessity to mount volumes to the container:</p> <pre><code>docker run --rm -v /path/to/base:/base -v /path/to/patches:/patches -o /path/to/output:/output tsladecek/ksux ksux -b /base -p /patches -o /output\n</code></pre>"}]}